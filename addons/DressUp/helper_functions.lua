-- Copyright (c) 2013, Cairthenn-- All rights reserved.-- Redistribution and use in source and binary forms, with or without-- modification, are permitted provided that the following conditions are met:    -- * Redistributions of source code must retain the above copyright      -- notice, this list of conditions and the following disclaimer.    -- * Redistributions in binary form must reproduce the above copyright      -- notice, this list of conditions and the following disclaimer in the      -- documentation and/or other materials provided with the distribution.    -- * Neither the name of DressUp nor the      -- names of its contributors may be used to endorse or promote products      -- derived from this software without specific prior written permission.-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND-- ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED-- WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE-- DISCLAIMED. IN NO EVENT SHALL Cairthenn BE LIABLE FOR ANY-- DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES-- (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;-- LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND-- ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.function get_item_id(str,slot)local item_result = false	if T{"none"}:contains(str) then		return "None"	else			for k,v in pairs(models[slot]) do			if v['enl'] == str or v['english'] == str then				item_result = k			end		end		if item_result then 			return tonumber(item_result)		else			return false		end	endendfunction make_packet_data(id)local packet_data	if id > 255 then		packet_data = string.char(id%256,math.floor(id/256))	else		packet_data = string.char(id)	end	return packet_dataend--Creates array of party IDs to check against blink logicfunction make_party_ids()party_member_list = {}for k,v in pairs(get_party()) do	if v["mob"] then		if windower.wc_match(k, 'p?|a?') then			table.append(party_member_list,v["mob"].id)		end	endendend-- Reinstates model blockingfunction FinishedZone()	zone_reset = falseendfunction do_blink_logic(blink_type,selection,id,pcindex)	if blink_type == "others" then		if selection == "always" then			if not table.contains(party_member_list,id) then				return true			else 				return false			end		elseif selection == "combat" then			if not table.contains(party_member_list,id) and get_player().in_combat then				return true			else				return false			end		else			if not table.contains(party_member_list,id) and (get_player().target_index == pcindex) then				return true			else				return false			end		end	elseif blink_type == "party" then		if selection == "always" then			if table.contains(party_member_list,id) then				return true			else 				return false			end		elseif selection == "combat" then			if table.contains(party_member_list,id) and get_player().in_combat then				return true			else				return false			end		else			if table.contains(party_member_list,id) and (get_player().target_index == pcindex) then				return true			else				return false			end		end	elseif blink_type == "self" then		if selection == "always" then			if get_player().id == id then				return true			else 				return false			end		elseif selection == "combat" then			if get_player().id == id and get_player().in_combat then				return true			else				return false			end		else			if get_player().id == id and (get_player().target_index == pcindex) then				return true			else				return false			end		end	elseif blink_type == "follow" then		if selection == "always" then			return true		elseif selection == "combat" then --This rule doesn't make much sense but I'll leave it for consistency.			if get_player().target_index == get_player().follow_index and get_player().in_combat then				return true			else				return false			end		else			if get_player().target_index == get_player().follow_index then				return true			else				return false			end		end	endendfunction print_blink_settings(option)	print('DressUp (v'.._addon.version..') Blink Prevention Settings') 	if option == "global" or option == "all" then	print(('All:    '):text_color(255,255,255)..table.concat(map(settings.blinking["all"],formatting)," "))	end	if option == "global" or option == "self" then	print(('Self:   '):text_color(255,255,255)..table.concat(map(settings.blinking["self"],formatting)," "))	end	if option == "global" or option == "others" then	print(('Others: '):text_color(255,255,255)..table.concat(map(settings.blinking["others"],formatting)," "))	end	if option == "global" or option == "party" then	print(('Party:  '):text_color(255,255,255)..table.concat(map(settings.blinking["party"],formatting)," "))	end	if option == "global" or option == "follow" then	print(('Follow: '):text_color(255,255,255)..table.concat(map(settings.blinking["follow"],formatting)," "))	endend--The following two are used in the formatting of blink rules into strings.function map(t, func)  local out = {}  for k,v in pairs(t) do    out[k] = func(k, v)  end  return outendfunction formatting(k, v) 	v = tostring(v):gsub("^%l", string.upper)	if windower.wc_match(v,"True") then		v = ('T'):text_color(0, 255, 0)	else		v = 'F'	end  return k:gsub("^%l", string.upper) ..': ['..v..']' end